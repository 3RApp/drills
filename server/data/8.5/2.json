{
  "title": "Реализация приложения 3RApp",
  "goals": [
    "Практическое освоение реализации приложения 3RApp.",
    "Закрепление понимания процесса реализации и его последовательности."
  ],
  "training_topic": "Реализация приложения 3RApp.",
  "required_resources": [
    "Проверочный список создания кода компонента, изложенный в книге на страницах 412 - 425.",
    "Артефакты созданные на этапе проектирования:",
    "1. Граф компонентов приложения.",
    "2. Таблица со свойствами, которые будут храниться в глобальном состоянии приложения.",
    "3. Таблица маппинга эндпоинтов на компоненты.",
    "4. Таблица с маршрутами для компонентов приложения."
  ],
  "instructions": [
    "Введение в упражнение:",
    "- Цель упражнения — научиться реализовывать приложение 3RApp, следуя этапам проектирования и используя граф компонентов и таблицу компонентов.",
    "",
    "Некоторые подразумеваемые условия перед началом: ",
    "1. Предполагается, что мы осуществили настройку приложения.",
    "2. Приложение на самом деле реализовано и скачать его можно в дополнительных материалах. Приложение (лендинг) реализовано не полностью как в дизайне (без детальной реализации CSS), только структура. А вот сами компоненты реализованы, кроме одного, код которого допишем в упражнении. ",
    "3. Мы будем идти пошагово объясняя шаги реализации на основе артефактов, которые были получены на этапе проектирования.",
    "4. Перед началом упражнения, убедитесь, что вы скачали необходимые артефакты.",
    "5. Также, перед началом упражнения рассмотрите артефакты и оцените их важность для реализации приложения.",
    "",
    "Шаг 1. StoreProvider:",
    "- Откройте граф компонентов и таблицу компонентов, созданные на этапе проектирования. Начинаем реализацию с самого первого компонента. Это компонент StoreProvider.",
    "- Откройте в приложении StoreProvider и посмотрите как реализован store, который импортируется в провайдер.",
    "- Если бы вы реализовывали самостоятельно, то необходимо было бы создать папку store, в которой нужно было бы реализовать слайс и сконфигурировать стор reduxtoolkit. Затем необходимо импортировать стор в провайдер в StoreProvider расположенный в index.js.",
    "- Этот компонент реализован, переходим к следующему.",
    "",
    "Шаг 2. Router:",
    "- Смотрим граф и следующий на очереди компонент Router.",
    "- Этот компонент предоставляется библиотекой ReactRouter. Использован компонент в index.js. Откройте этот файл и посмотрите как реализован роутинг.",
    "- Если бы вы реализовывали самостоятельно, то необходимо было бы импортировать компонент Router из библиотеки ReactRouter и добавить в index.js. Дополнительно из библиотеки нужно было бы импортировать компоненты Route и Routes.",
    "- Компонент Router является родительским для всех компонентов которые должны управляться маршрутизацией. В нашем случае это страница лэндинга - компонент LandingPage.",
    "- Компонент Router должен включать в себя Routes и Route. Route отвечает за определение маршрутов. Routes отвечает за отображение компонентов в зависимости от маршрута.",
    "- Этот компонент реализован, переходим к следующему.",
    "",
    "Шаг 3. Layout:",
    "- Смотрим граф и следующий на очереди компонент Layout.",
    "- Это первый компонент, число дочерних компонентов которого больше одного.",
    "- Откройте компонент Layout и посмотрите как он реализован.",
    "- Этот компонент является родительским для компонентов Header, Footer, Nagigation и LandingPage.",
    "- Если бы вы реализовывали самостоятельно, то необходимо было бы для компонентов Header, Footer, Navigation и LandingPage добавить @TODO, так как они на момент начала реализации Layout еще не реализованы. На самом для такого простого случая, как у Layout, сначала можно реализовать компоненты Header, Footer, Navigation и затем их добавить сразу в Layout. В случае с LandingPage, нужно будет добавить @TODO, так как он является сложным компонентом состоящим из других дочерних.",
    "- Теперь поочередно откройте компоненты Header, Footer и Nagigation и посмотрите как они реализованы.",
    "- Этот компонент реализован, переходим к следующему.",
    "",
    "Шаг 4. LandingPage:",
    "- Смотрим граф и следующий на очереди компонент LandingPage.",
    "- Этот компонент является дочерним для компонента Layout. Сам компонент LandingPage импортирует дочерние бизнес-компоненты: CallToAction, BusinessEvent, Service, Confirmation, Feedback, Registration и AboutCompany.",
    "- Откройте компонент LandingPage и посмотрите как он реализован.",
    "- Если бы вы реализовывали самостоятельно, то необходимо было бы для компонентов CallToAction, BusinessEvent, Service, Confirmation, Feedback, Registration и AboutCompany добавить @TODO, так как они на момент начала реализации LandingPage еще не реализованы. И когда наступил бы момент, когда они будут реализованы, то можно было бы их импортировать в LandingPage и убрать @TODO.",
    "- Этот компонент реализован, переходим к следующему.",
    "",
    "Шаг 5. CallToAction, BusinessEvent, Service, Confirmation, Feedback, Registration и AboutCompany:",
    "- Смотрим граф и следующий на очереди компонент - CallToAction - являющийся первым дочерним компонентом LandingPage.",
    "- Посмотрите его реализацию.",
    "- Если бы вы реализовывали его самостоятельно, то вам нужно было бы добавить @TODO, так как на момент начала реализации CallToAction еще не реализованы компоненты Heading, Button. И когда они были бы реализованы, то можно было бы их импортировать в CallToAction и убрать @TODO.",
    "- Затем перейдите ко второму дочернему компоненту BusinessEvent.",
    "- Посмотрите его реализацию.",
    "- Если бы вы реализовывали его самостоятельно, то вам нужно было бы добавить @TODO, так как на момент начала реализации BusinessEvent еще не реализованы компоненты Heading, Text. И когда они были бы реализованы, то можно было бы их импортировать в BusinessEvent и убрать @TODO.",
    "- Посмотрите его реализацию.",
    "- Затем перейдите к третьему дочернему компоненту Service и посмотрите его реализацию.",
    "- Затем перейдите к четвертому дочернему компоненту Confirmation и посмотрите его реализацию.",
    "- Затем перейдите к пятому дочернему компоненту Feedback и посмотрите его реализацию.",
    "",
    "- Затем перейдите к шестому дочернему компоненту Registration и на нём мы остановимся подробнее и реализуем его.",
    "- Откройте заготовленный шаблон файла src/business/Registration.js.",
    "- Возьмите в руки проверочный список создания кода компонента.",
    "- Задержитесь на шаге два первого этапа списка. Давайте оценим вместе. Компонент Registration присутствует в таблице маппинга эндпоинтов на компоненты:",
    "---------------------------------------------",
    "|    /api/v1/participant | Registration",
    "---------------------------------------------",
    "- Но встаёт вопрос, будем ли мы реализовывать этот шаг?",
    "- На самом деле нет. Этап один отвечает за получение данных. Тогда как мы должны отправить мутирующий запрос, поэтому данный шаг мы пропускаем. Переходите к третьему шагу, прочтите его и прикиньте его необходимость. Можете еще раз прочтитать требование к разделу \"Регистрация на мероприятие\"",
    "- Поскольку в требованиях сказано, что нужно показывать сообщение об успешной регистрации и об ошибке, но тело ответа не обязательно содержит нужный текст, нам надо понимать, был ли ответ успешным или нет. Поскольку мы должны показывать пользователю сообщение, то нам понадобится создать для этого JSX для успешного случая, для случая с ошибкой и должен быть вывод по-умолчанию, а также нам нужно управление переходом между состояниями.",
    "- Нам необходимо три состояния запроса на регистрацию: 1) в ожидании отправки данных на регистрацию (idle), 2) успех (success), 3) ошибка (error). Также нам необходимо уведомлять пользователя об ожидании ответа при отправке данных на регистрацию. Нам необходимо два состояния на этапе отправке запроса: 1) ожидание ответа, 2) ожидание создания запроса.",
    "- Для запроса на регистрацию, у нас будет одна переменная состояния registrationRequest. Для загрузки у нас будет вторая переменная loading.",
    "- Добавим их в код компонента:",
    {
      "type": "code",
      "title": "Переменные состояния",
      "code": "import { useState } from \"react\";"
    },
    {
      "type": "code",
      "title": "Переменные состояния",
      "code": "const [registration, setRegistration] = useState('idle'); const [loading, setLoading] = useState(false);"
    },
    "- Теперь перейдите к четвертому и пятому шагам. Прочтите их и прикиньте их необходимость.",
    "- Шаг 6. Компонент должен получать данные из стора. Такова задумка с самого начала. Изучите действия описываемые в проверочном списке для шага 6.",
    "- Допишем код: ",
    {
      "type": "code",
      "title": "Импорт хука useSelector из react-redux",
      "code": "import { useSelector } from \"react-redux\";"
    },
    "- Данный код нужно добавить в начало файла src/business/Registration.js.",
    "- Также импортируем селектор и передадим его в useSelector.",
    {
      "type": "code",
      "title": "Импорт селектора и передача его в useSelector",
      "code": "import { selectFullName, selectPhone } from \"../store/visitorSlice.js\";"
    },
    "- Данный код нужно расположить в первой строке внутри компонента.",
    "- Передадим селекторы в хуки и присвоим возвращаемые значения переменным.",
    {
      "type": "code",
      "title": "Вызов useSelector и присвоение возвращаемых значений",
      "code": "const fullName = useSelector(selectFullName); const phoneNumber = useSelector(selectPhone);"
    },
    "- Данный код нужно расположить после предыдущего кода.",
    "- Дойдите до конца этапа 1 читая шаги и прикидывая их применимость.",
    "",
    "- Теперь перейдите на этап 2 проверочного списка создания кода компонента.",
    "- Этот этап состоит из единственного шага. Определите его необходиомость. При необходимости выполните написание нужного кода.",
    "- Теперь перейдите на этап 3 проверочного списка создания кода компонента.",
    "- Начинайте читать шаги этапа 3 с шага 12.",
    "- Выполните шаг 13 самостоятельно и затем перейдите к шагу 14. Определите его необходиомость. При необходимости выполните написание нужного кода.",
    "- Выполним шаг 15. Нам нужно добавить JSX для вывода данных. Замените <Button title=\"ЗАРЕГИСТРИРОВАТЬ\" /> на следующий код:",
    {
      "type": "code",
      "title": "JSX для вывода данных",
      "code": "<form method='post'><div><label htmlFor=\"fullName\">ФИО</label><input id=\"fullName\" name=\"fullName\" type=\"text\" placeholder=\"Введите ФИО\" value={fullName} /></div><div><label htmlFor=\"phone\">Телефон</label><input id=\"phone\" name=\"phone\" type=\"tel\" placeholder=\"+7 (___) ___-__-__\" value={phoneNumber} /></div><Button title=\"ЗАРЕГИСТРИРОВАТЬ\" /></form>"
    },
    "- Протестируйте результат в браузере.",
    "- Теперь изучите шаги 16, 17 и 18 и определите их необходиомость. При необходимости выполните написание нужного кода.",
    "- Выполним шаг 19.",
    "- В шаге 3 мы с вами определили переменные, которые управляют запросом на регистрацию. Теперь нужно добавить JSX, который будет выводиться в зависимости от их состояния.",
    "- Дополните код компонента следующими кодами: ",
    {
      "type": "code",
      "title": "Вывод jSX при выполнении запроса на регистрацию",
      "code": "if (loading) { return (<section>Запрос на регистрацию отправлен, ожидаем ответ!</section>)};"
    },
    "- Разместите код перед return.",
    {
      "type": "code",
      "title": "Вывод jSX при успешном выполнении запроса на регистрацию",
      "code": "if (registration === 'success') { return (<section>Вы зарегистрированы на мероприятие! <Button title='Закрыть' /></section>)};"
    },
    "- Добавьте данный код ниже, чем предыдущий.",
    {
      "type": "code",
      "title": "Вывод jSX при ошибочном выполнении запроса на регистрацию",
      "code": "if (registration === 'error') { return (<section>Во время регистрации произошла ошибка. Повторите попытку позже. <Button title='Закрыть' /></section>)};"
    },
    "- Добавьте данный код ниже, чем предыдущий.",
    "- Если состояние registration не определено (то есть idle), то выводим jSX по умолчанию.",
    "- На этом этап 3 проверочного списка завершен, переходим к этапу 4.",
    "- Ознакомьтесь с шагами 20, 21 и 22.",
    "- Мы реализуем шаг 22. Нам нужно отправить мутирующий запрос на регистрацию. Добавьте код:",
    {
      "type": "code",
      "title": "Создание кода для отправки запроса на регистрацию",
      "code": "const handleSubmit = async (e) => { e.preventDefault(); const formData = new FormData(e.target); try { const res = await fetch('/api/v1/participant', { method: 'POST', body: formData }); const data = res.ok ? await res.json() : null; data?.success ? setRegistration('success') : setRegistration('error'); } catch { setRegistration('error'); } finally { setLoading(false); } };"
    },
    "- В шаге 22 нам предоставляется выбор. Если задействовать возможности Reactrouter, то нам пришлось бы использовать создание маршрутов при помощи createBrowserRouter. У нас используется компонент а не функция, поэтому задействуем WebAPI.",
    "- Теперь нужно добавить ссылку на обработчик события onSubmit:",
    {
      "type": "code",
      "title": "Добавление ссылки на обработчик события onSubmit",
      "code": "<form method='post' onSubmit={handleSubmit}>/*Здесь другой код формы*/"
    },
    "- Перейдите к шагу 23 и прочтите его. В шаге 19 нам потребовалось вывести JSX по условию. Однако JSX добавленный на шаге 19 содержал элемент формы Button и в них не было обработчиков. Поэтому мы добавим обработчики в Button на шаге 23.",
    "- Добавим следующий код: ",
    {
      "type": "code",
      "title": "Создаём обработчик события закрытия сообщения об успешной регистрации",
      "code": "const handleClose = () => { setRegistration('idle') };"
    },
    "- Затем добавим ссылку на обработчик в оба JSX Button, что расположены в сообщениях и об успешной регистрации и об ошибке во время регистрации.",
    {
      "type": "code",
      "title": "Добавление ссылки на обработчик события handleClose",
      "code": "<Button title='Закрыть' onClick={handleClose} />"
    },    
    "- На этом шаг 23 законечн. Дойдите до конца этапа 4 и прочтите все шаги. При необходимости реализуйте.",
    "- Этап 5.",
    "- Ознакомьтесь с шагом 26, а затем с шагом 27. Остановимся на шаге 27. В действительности до сих пор наши данные не сохранялись в сторе. Теперь нужно добавить код для сохранения данных в нём. Добавьте следующий код:",
    {
      "type": "code",
      "title": "Импортируем useDispatch",
      "code": "import { useSelector, useDispatch } from 'react-redux';"
    },  
    "- Производим вызов хука и присваиваем возвращаемое значение переменной dispatch:",
    {
      "type": "code",
      "title": "Импортируем useDispatch",
      "code": "const dispatch = useDispatch();"
    },
    "- Импортируем экшен-криэйтеры:",
    {
      "type": "code",
      "title": "Импортируем экшен-криэйтеры",
      "code": "import { selectFullName, selectPhone, setFullName, setPhone } from '../store/visitorSlice.js';"
    },
    "- Создаём обработчик:",
    {
      "type": "code",
      "title": "Обработчик события change",
      "code": "const handleChange = (e) => dispatch(e.target.name === 'fullName' ? setFullName(e.target.value) : setPhone(e.target.value));"
    },
    "- Добавляем ссылку на обработчик события в каждый input:",
    {
      "type": "code",
      "title": "Добавление ссылки на обработчик события change в каждый input",
      "code": "<input id='fullName' onChange={handleChange} /*другой код*/"
    },
    "- Однако имейте ввиду React выдаёт предупреждение, если оставить компонент не управляемым. Его не устраивает, что в input будет подаваться значение не из состояния контролируемого хуком useState.",
    "- React выдаст предупреждение и даст ссылку для ознакомления: https://react.dev/reference/react-dom/components/input#controlling-an-input-with-a-state-variable",
    "- Решайте сами, что с этим делать.",
    "- Этапы 6 и 7.",
    "- Ознакомьтесь со всеми шагами этапов 6 и 7.",
    "- Если бы вы реализовывали самостоятельно эти этапы для компонента Registration, то вам пришлось бы выполнить некоторые шаги на этапе 7.",
    "- Смотрим граф и следующий на очереди компонент - Heading - являющийся дочерним компонентом Registration.",
    "- Да, мы бы уже реализовали его раньше, так как мы рассматривали коды бизнес-компонентов, где данный простой конечный компонент уже встречался. ",
    "- Посмотрите его реализацию.",
    "- Если бы вы реализовывали его самостоятельно, то вам нужно было бы просто его реализовать и всё. Простые конечные компоненты реализуются одномоментно.",
    "- Смотрим граф и следующий на очереди компонент - Button - также являющийся дочерним компонентом Registration.",
    "- Посмотрите его реализацию.",
    "- Смотрим граф и следующий на очереди компонент - AboutCompany - являющийся дочерним компонентом LandingPage.",
    "- Посмотрите его реализацию.",
    "- Если бы вы реализовывали его самостоятельно, то вам нужно было бы добавить @TODO, так как на момент начала реализации AboutCompany еще не реализованы компоненты Heading, Button. И когда они были бы реализованы, то можно было бы их импортировать в AboutCompany и убрать @TODO.",
    "- На этом реализация бизнес-компонентов заканчивается. Переходим к простым конечным компонентам.",
    "",
    "Шаг 6. Реализация простых конечных компонентов:",
    "- Смотрим граф и следующий на очереди компонент - Text - также являющийся дочерним компонентом бизнес-компонентов: BusinessEvent, Service, Confirmation, Feedback, AboutCompany.",
    "- Вероятнее всего он уже был бы реализован к этому моменту.",
    "- Посмотрите его реализацию.",
    "На этом реализация приложения заканчивается.",
    "",
    "Заключение:",
    "- Такой артефакт, как граф, является вашим путеводителем по тому, что в данный момент реализовывать.",
    "- Заранее заготовленные таблица со страницами и бизнес-компонентами, глобальное состояние, таблица маппинга эндпоинтов на компоненты и таблица маппинга УРЛ на компоненты сильно упрощает реализацию.",
    ""
  ],
  "reflection_questions": [
    "Какие этапы реализации приложения 3RApp наиболее важны для создания качественного приложения?",
    "Как использование графов компонентов и таблиц компонентов помогает в реализации приложения?",
    "Какие преимущества и недостатки у подхода к реализации приложения 3RApp по сравнению с другими подходами?"
  ],
  "additional_materials": [
    "Книга \"Разработка фронтенд-приложений\".",
    {
        "type": "link",
        "title": "Архивный файл для выполнения упражнения",
        "name": "1",
        "folder": "2",
        "chapter": "8.5"
    } 
  ],
  "final_conclusion": [
    "Вы освоили процесс реализации приложения 3RApp, что позволит вам создавать качественные и функциональные фронтенд-приложения, соответствующие требованиям заказчика."
  ]
}